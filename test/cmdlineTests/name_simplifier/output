Optimized IR:
/*******************************************************
 *                       WARNING                       *
 *  Solidity to Yul compilation is still EXPERIMENTAL  *
 *       It can result in LOSS OF FUNDS or worse       *
 *                !USE AT YOUR OWN RISK!               *
 *******************************************************/

object "C_59" {
    code {
        {
            mstore(64, 128)
            if callvalue() { revert(0, 0) }
            let _1 := datasize("C_59_deployed")
            codecopy(128, dataoffset("C_59_deployed"), _1)
            return(128, _1)
        }
    }
    object "C_59_deployed" {
        code {
            {
                let _1 := 64
                mstore(_1, 128)
                if iszero(lt(calldatasize(), 4))
                {
                    let _2 := 0
                    if eq(0xf8eddcc6, shr(224, calldataload(_2)))
                    {
                        if callvalue() { revert(_2, _2) }
                        let _3 := 32
                        if slt(add(calldatasize(), not(3)), _3) { revert(_2, _2) }
                        let offset := calldataload(4)
                        let _4 := 0xffffffffffffffff
                        if gt(offset, _4) { revert(_2, _2) }
                        if iszero(slt(add(offset, 35), calldatasize())) { revert(_2, _2) }
                        let _5 := calldataload(add(4, offset))
                        if gt(_5, _4) { panic_error_0x41() }
                        let _6 := shl(5, _5)
                        let memPtr := mload(_1)
                        let _7 := not(31)
                        let newFreePtr := add(memPtr, and(add(_6, 63), _7))
                        if or(gt(newFreePtr, _4), lt(newFreePtr, memPtr)) { panic_error_0x41() }
                        mstore(_1, newFreePtr)
                        let dst := memPtr
                        mstore(memPtr, _5)
                        dst := add(memPtr, _3)
                        let dst_1 := dst
                        let src := add(offset, 36)
                        if gt(add(add(offset, _6), 36), calldatasize()) { revert(_2, _2) }
                        let i := _2
                        for { } lt(i, _5) { i := add(i, 1) }
                        {
                            if slt(sub(calldatasize(), src), _3) { revert(_2, _2) }
                            let memPtr_1 := mload(_1)
                            let newFreePtr_1 := add(memPtr_1, _3)
                            if or(gt(newFreePtr_1, _4), lt(newFreePtr_1, memPtr_1)) { panic_error_0x41() }
                            mstore(_1, newFreePtr_1)
                            mstore(memPtr_1, calldataload(src))
                            mstore(dst, memPtr_1)
                            dst := add(dst, _3)
                            src := add(src, _3)
                        }
                        if iszero(mload(memPtr)) { panic_error_0x32() }
                        sstore(_2, mload(mload(dst_1)))
                        if iszero(lt(1, mload(memPtr))) { panic_error_0x32() }
                        let _8 := mload(mload(add(memPtr, _1)))
                        sstore(0x02, _8)
                        let memPtr_2 := mload(_1)
                        let newFreePtr_2 := add(memPtr_2, 160)
                        if or(gt(newFreePtr_2, _4), lt(newFreePtr_2, memPtr_2)) { panic_error_0x41() }
                        mstore(_1, newFreePtr_2)
                        mstore(memPtr_2, 100)
                        mstore(add(memPtr_2, _3), "longstringlongstringlongstringlo")
                        mstore(add(memPtr_2, _1), "ngstringlongstringlongstringlong")
                        let _9 := 96
                        mstore(add(memPtr_2, _9), "stringlongstringlongstringlongst")
                        mstore(add(memPtr_2, 128), "ring")
                        let memPos := mload(_1)
                        mstore(memPos, _8)
                        mstore(add(memPos, _3), _1)
                        let length := mload(memPtr_2)
                        mstore(add(memPos, _1), length)
                        let i_1 := _2
                        for { } lt(i_1, length) { i_1 := add(i_1, _3) }
                        {
                            mstore(add(add(memPos, i_1), _9), mload(add(add(memPtr_2, i_1), _3)))
                        }
                        if gt(i_1, length)
                        {
                            mstore(add(add(memPos, length), _9), _2)
                        }
                        return(memPos, add(sub(add(memPos, and(add(length, 31), _7)), memPos), _9))
                    }
                }
                revert(0, 0)
            }
            function panic_error_0x32()
            {
                mstore(0, shl(224, 0x4e487b71))
                mstore(4, 0x32)
                revert(0, 0x24)
            }
            function panic_error_0x41()
            {
                mstore(0, shl(224, 0x4e487b71))
                mstore(4, 0x41)
                revert(0, 0x24)
            }
        }
    }
}
